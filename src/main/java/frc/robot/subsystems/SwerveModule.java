// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import frc.robot.Constants;
import frc.robot.Robot;

import com.revrobotics.RelativeEncoder;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.sensors.CANCoder;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS



/**
 * https://www.swervedrivespecialties.com/products/mk4i-swerve-module?variant=39598777270385
 */
public class SwerveModule{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANCoder cANCoder;
    final private CANSparkMax driveSparkMax;
    final private CANSparkMax turnSparkMax;

    final private RelativeEncoder driveEncoder;
    final private RelativeEncoder turnEncoder;

    final private double TURN_P = 0.002;
    final private double TURN_I = 0.0001;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public double getTURN_P() {
        return TURN_P;
    }

    final private String module_id;

    private double location_x = 0.0, location_y = 0.0;

    private double driveGearRatio = 8.14; // MK4i: 8.14 or 6.75 or 6.12
    private double turnGearRatio = 150./7.;

    private double base_angle;

    public static double maxTurnSpeed = 0.3;
    public static double maxDriveSpeed = 0.4;
    private double turnIntegratorRange = 0.01;

    private boolean enable_turn = true;
    private boolean enable_drive = true;

    private double turnVel = 0.0;

    private PIDController angle_pid;
    private final double wheelDiameter = 3.585;
    private final NetworkTable swerve_table;
    private final NetworkTableEntry turn_setpoint;
    private final NetworkTableEntry drive_setpoint;
    private final NetworkTableEntry turn_angle;
    private final NetworkTableEntry drive_velocity;
    private final NetworkTableEntry init_base_angle;
    public final float lockAngle;

    public SwerveModule(String module_id, int cancoder_id, int drive_motor_id, int turn_motor_id, double base_angle, float lockAngle){
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        this.module_id = module_id;
        this.base_angle = base_angle;
        this.lockAngle = lockAngle;

        cANCoder = new CANCoder(cancoder_id);
 
        driveSparkMax = new CANSparkMax(drive_motor_id, MotorType.kBrushless);
        turnSparkMax = new CANSparkMax(turn_motor_id, MotorType.kBrushless);

        driveSparkMax.restoreFactoryDefaults();
        driveSparkMax.setInverted(false);
        driveSparkMax.setIdleMode(IdleMode.kCoast);
        driveSparkMax.burnFlash();

        turnSparkMax.restoreFactoryDefaults();
        turnSparkMax.setInverted(false);
        turnSparkMax.setIdleMode(IdleMode.kCoast);
        turnSparkMax.burnFlash();
        

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // This line will override the constructor base_angle parameter with
        // the current CANCoder position on initial startup
       // this.base_angle = getCancoderAbsPosition();
    
        driveEncoder = driveSparkMax.getEncoder();
        turnEncoder = turnSparkMax.getEncoder();
        driveEncoder.setPositionConversionFactor(1/2);
        
        

        NetworkTableInstance inst = NetworkTableInstance.getDefault();
        swerve_table = inst.getTable("swerve_chassis").getSubTable("module_" + module_id);
        swerve_table.getEntry("module_id").setString(module_id);
        
        turn_setpoint = swerve_table.getEntry("turn_setpoint");
        turn_setpoint.setDouble(0.0);
        drive_setpoint = swerve_table.getEntry("drive_setpoint");
        drive_setpoint.setDouble(0.0);
        turn_angle = swerve_table.getEntry("turn_angle");
        turn_angle.setDouble(0.0);
        drive_velocity = swerve_table.getEntry("drive_velocity");
        drive_velocity.setDouble(0.0);
        init_base_angle = swerve_table.getEntry("init_base_angle");
        init_base_angle.setDouble(this.base_angle);
    }
    double I;
    double P;
    // This method will run repetitively while the robot is running
    public void periodic() {
        double ang = getCancoderAbsPosition();
        turn_angle.setDouble(ang);
        double ts = turn_setpoint.getDouble(0.0);

        I = NetworkTableInstance.getDefault().getTable("PID").getEntry("I").getDouble(0.0);
        P = NetworkTableInstance.getDefault().getTable("PID").getEntry("P").getDouble(0.0);
        //0.007500, 0.0250
        angle_pid = new PIDController(.0075, .025, 0.0000);
        angle_pid.enableContinuousInput(0.0, 360);
        angle_pid.setTolerance(2.0, 2.0);
        angle_pid.setIntegratorRange(-turnIntegratorRange, turnIntegratorRange);
        //ts = computeAdjustedAngle(ts);
        //Hello I made a change to verify if everything works.
        angle_pid.setSetpoint(ts);    
        turnVel = angle_pid.calculate(getCancoderAbsPosition());
        setTurnSpeed(-turnVel);

        double ds = drive_setpoint.getDouble(0.0);
        setDriveSpeed(ds);
}

    // Make sure the angle is not greater than 360 or less than 0
    private double clipAngle(double angle){ 
        return (angle)% 360;
    }

    private double computeAdjustedAngle(double angle){ 
        return (base_angle+angle);
    }

    // This method will be called once per scheduler run when in simulation
    public void simulationPeriodic() {
    }

    // ----------------- Setter Methods ----------------- \\
    public void setMaxTurnSpeed(double value) {
        maxTurnSpeed = value;
    }
    
    public void setMaxDriveSpeed(double value) {
        maxDriveSpeed = value;
    }

    // Set the angle of this wheel
    public void setAngle(double value, boolean locked) {
        //value = clipAngle(value);
        if (locked) {   // Default the angle to the lock angle if the wheels are locked
            value = lockAngle;
        }
        turn_setpoint.setDouble(value);
    }

    // Set the velocity of this wheel
    public void setVelocity(double value, boolean locked) {
        if (locked) {   // Default the velocity to 0 if the wheels are locked
            value = 0;
        }
        drive_setpoint.setDouble(value);
    }

    // Set the velocity and angle of this wheel
    public void setStates(SwerveModuleState state, boolean locked){
        
   
        state = new SwerveModuleState(state.speedMetersPerSecond, state.angle.rotateBy(Rotation2d.fromDegrees(base_angle)));
        state = optimize(state, Rotation2d.fromDegrees(cANCoder.getAbsolutePosition())); 
        
        setAngle(state.angle.getDegrees(), locked);
        setVelocity(state.speedMetersPerSecond, locked);
    }
    // Set the turn speed of this wheel (the speed will be limited to be in [-maxTurnSpeed, maxTurnSpeed])
    private void setTurnSpeed(double speed) {
        if (enable_turn) {
            // limit the speed
            speed = Math.max(Math.min(speed, maxTurnSpeed), -maxTurnSpeed);
            turnSparkMax.set(speed);
        }
    }
    
    private SwerveModuleState optimize(SwerveModuleState desiredState, Rotation2d currentAngle) {
        var delta = desiredState.angle.minus(currentAngle);
        if (Math.abs(delta.getDegrees()) > 90.0) {
            return new SwerveModuleState(
                -desiredState.speedMetersPerSecond,
                desiredState.angle.rotateBy(Rotation2d.fromDegrees(180.0)));
        } else {
            return new SwerveModuleState(desiredState.speedMetersPerSecond, desiredState.angle);
        }
    }
    

    // Set the speed of this wheel (the speed will be limited to be in [-maxDriveSpeed, maxDriveSpeed])
    private void setDriveSpeed(double velocity) {
        if (enable_drive) {
            velocity = Math.max(Math.min(velocity, maxDriveSpeed), -maxDriveSpeed);
            driveSparkMax.set(velocity * Constants.speedDampener);
        }
    }
    public void setIdleMode(IdleMode bMode){
        driveSparkMax.setIdleMode(bMode);
        turnSparkMax.setIdleMode(bMode);
    }


    // ----------------- Getter Methods ----------------- \\
    public double getMaxTurnSpeed() {
        return maxTurnSpeed;
    }

    public double getMaxDriveSpeed() {
        return maxDriveSpeed;
    }

    public double getAngle() {
        return turn_setpoint.getDouble(0.0);
    }

    public void getVelocity() {
        drive_setpoint.getDouble(0.0);
    }

    public double getCancoderAbsPosition() {
        return cANCoder.getAbsolutePosition();
    }

    double getTurnMotorValue() {
        return turnSparkMax.get();
    }

    double getDriveMotorValue() {
        return driveSparkMax.get();
    }
    public RelativeEncoder getEncoder(){
        return driveEncoder;
    }

}