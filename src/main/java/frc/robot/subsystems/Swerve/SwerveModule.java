// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems.Swerve;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import frc.robot.Constants;

import com.revrobotics.RelativeEncoder;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.sensors.CANCoder;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 * https://www.swervedrivespecialties.com/products/mk4i-swerve-module?variant=39598777270385
 */
public class SwerveModule {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANCoder cANCoder;
    final public CANSparkMax driveSparkMax;
    final private CANSparkMax turnSparkMax;

    final private RelativeEncoder driveEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    final private String module_id;

    // private double location_x = 0.0, location_y = 0.0;

    // private double driveGearRatio = 8.14; // MK4i: 8.14 or 6.75 or 6.12
    // private double turnGearRatio = 150./7.;

    private double base_angle;

    public static double maxTurnSpeed = 0.3;
    public static double maxDriveSpeed = 0.8;
    private double turnIntegratorRange = 0.01;

    private boolean enable_turn = true;
    private boolean enable_drive = true;

    private double turnVel = 0.0;

    private PIDController angle_pid;
    // balls
    // private final double wheelDiameter = 3.585;
    private final NetworkTable swerve_table;
    private final NetworkTableEntry turn_setpoint;
    private final NetworkTableEntry drive_setpoint;
    private final NetworkTableEntry turn_angle;
    private final NetworkTableEntry drive_velocity;
    private final NetworkTableEntry init_base_angle;
    private final NetworkTableEntry speedDampening;
    public final float lockAngle;
    double m_last_encoder = 0.0;
    double m_position = 0.0;

    public SwerveModule(String module_id, int cancoder_id, int drive_motor_id, int turn_motor_id, double base_angle,
            float lockAngle) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        this.module_id = module_id;
        this.base_angle = base_angle;
        this.lockAngle = lockAngle;

        cANCoder = new CANCoder(cancoder_id);

        driveSparkMax = new CANSparkMax(drive_motor_id, MotorType.kBrushless);
        turnSparkMax = new CANSparkMax(turn_motor_id, MotorType.kBrushless);

        driveSparkMax.restoreFactoryDefaults();
        driveSparkMax.setInverted(false);
        driveSparkMax.setIdleMode(IdleMode.kBrake);

        double gear_rat = 1.0 / 8.14;
        driveSparkMax.setSmartCurrentLimit(35);

        // converts inches to meters
        double wheel_cer = 4.0 * 0.0254 * Math.PI;
        driveSparkMax.getEncoder().setVelocityConversionFactor(gear_rat * wheel_cer);
        driveSparkMax.getEncoder().setPositionConversionFactor(8.14 /4 * .0254);

        driveSparkMax.burnFlash();

        turnSparkMax.restoreFactoryDefaults();
        turnSparkMax.setInverted(false);
        turnSparkMax.setIdleMode(IdleMode.kCoast);
        turnSparkMax.burnFlash();

        turnSparkMax.setSmartCurrentLimit(35);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // This line will override the constructor base_angle parameter with
        // the current CANCoder position on initial startup
        // this.base_angle = getCancoderAbsPosition();

        driveEncoder = driveSparkMax.getEncoder();

        speedDampening = NetworkTableInstance.getDefault().getTable("swerve_chassis").getEntry("speed_dampening");

        NetworkTableInstance inst = NetworkTableInstance.getDefault();
        swerve_table = inst.getTable("swerve_chassis").getSubTable("module_" + this.module_id);
        swerve_table.getEntry("module_id").setString(this.module_id);

        turn_setpoint = swerve_table.getEntry("turn_setpoint");
        turn_setpoint.setDouble(0.0);
        drive_setpoint = swerve_table.getEntry("drive_setpoint");
        drive_setpoint.setDouble(0.0);
        turn_angle = swerve_table.getEntry("turn_angle");
        turn_angle.setDouble(0.0);
        drive_velocity = swerve_table.getEntry("drive_velocity");
        drive_velocity.setDouble(0.0);
        init_base_angle = swerve_table.getEntry("init_base_angle");
        init_base_angle.setDouble(this.base_angle);
        // spell "ICUP"
        // 0.007500, 0.0250
        angle_pid = new PIDController(P, I, 0.0000);
        angle_pid.enableContinuousInput(0.0, 360);
        angle_pid.setTolerance(2.0, 2.0);
        angle_pid.setIntegratorRange(-turnIntegratorRange, turnIntegratorRange);
    }

    double P = 0.0075;
    double I = 0.025;

    // This method will run repetitively while the robot is running
    public void periodic() {
        double ang = getCancoderAbsPosition();
        turn_angle.setDouble(ang);
        double ts = turn_setpoint.getDouble(0.0);

        P = NetworkTableInstance.getDefault().getTable("PID").getEntry("P").getDouble(0.0);

        I = NetworkTableInstance.getDefault().getTable("PID").getEntry("I").getDouble(0.0);

        // 0.007500, 0.0250
        angle_pid = new PIDController(.0075, .025, 0.0000);
        angle_pid.enableContinuousInput(0.0, 360);
        angle_pid.setTolerance(2.0, 2.0);
        angle_pid.setIntegratorRange(-turnIntegratorRange, turnIntegratorRange);
        // spell "ICUP"
        // ts = computeAdjustedAngle(ts);
        // Hello I made a change to verify if everything works.
        angle_pid.setSetpoint(ts);
        turnVel = angle_pid.calculate(getCancoderAbsPosition());
        setTurnSpeed(-turnVel);

        double ds = drive_setpoint.getDouble(0.0);
        setDriveSpeed(ds);
    }

    // Make sure the angle is not greater than 360 or less than 0
    /*
     * private double clipAngle(double angle){
     * return (angle)% 360;
     * }
     * 
     * private double computeAdjustedAngle(double angle){
     * return (base_angle+angle);
     * }
     */

    // This method will be called once per scheduler run when in simulation
    public void simulationPeriodic() {
    }

    // ----------------- Setter Methods ----------------- \\
    public void setMaxTurnSpeed(double value) {
        maxTurnSpeed = value;
    }

    public void setMaxDriveSpeed(double value) {
        maxDriveSpeed = value;
    }

    // Set the angle of this wheel
    public void setAngle(double value, boolean locked) {
        // value = clipAngle(value);
        if (locked) { // Default the angle to the lock angle if the wheels are locked
            value = lockAngle;
        }
        turn_setpoint.setDouble(value);
    }

    // Set the velocity of this wheel
    public void setVelocity(double value, boolean locked) {
        if (locked) { // Default the velocity to 0 if the wheels are locked
            value = 0;
        }
        drive_setpoint.setDouble(value);
    }

    // Set the velocity and angle of this wheel
    public void setStates(SwerveModuleState state, boolean locked) {

        state = new SwerveModuleState(state.speedMetersPerSecond,
                state.angle.rotateBy(Rotation2d.fromDegrees(base_angle)));
        state = optimize(state, Rotation2d.fromDegrees(cANCoder.getAbsolutePosition()));

        setAngle(state.angle.getDegrees(), locked);
        setVelocity(state.speedMetersPerSecond, locked);
    }

    // Set the turn speed of this wheel (the speed will be limited to be in
    // [-maxTurnSpeed, maxTurnSpeed])
    private void setTurnSpeed(double speed) {
        if (enable_turn) {
            // limit the speed
            speed = Math.max(Math.min(speed, maxTurnSpeed), -maxTurnSpeed);
            turnSparkMax.set(speed);
        }
    }

    private SwerveModuleState optimize(SwerveModuleState desiredState, Rotation2d currentAngle) {
        var delta = desiredState.angle.minus(currentAngle);
        if (Math.abs(delta.getDegrees()) > 90.0) {
           /* double encoder = driveEncoder.getPosition();
            m_position += encoder - m_last_encoder;
            m_last_encoder = encoder;
            System.out.printf("mid: %s pos: %f encoderF: %f\n", module_id,m_position, encoder);
            */
            return new SwerveModuleState(
                    -desiredState.speedMetersPerSecond,
                    desiredState.angle.rotateBy(Rotation2d.fromDegrees(180.0)));
        } else {
            /*
            double encoder = driveEncoder.getPosition();
            m_position += encoder - m_last_encoder;
            m_last_encoder = encoder;
            System.out.printf("mid: %s pos: %f encoderR: %f\n", module_id,m_position, encoder);
            */
            return new SwerveModuleState(desiredState.speedMetersPerSecond, desiredState.angle);

        }
    }

    double getPositionEstimate() {
        return m_position;

    }

    // Set the speed of this wheel (the speed will be limited to be in
    // [-maxDriveSpeed, maxDriveSpeed])
    private void setDriveSpeed(double velocity) {
        if (enable_drive) {
            velocity = Math.max(Math.min(velocity, maxDriveSpeed), -maxDriveSpeed);
            driveSparkMax.set(velocity * speedDampening.getDouble(Constants.defaultDampening));
        }
    }

    public void setIdleMode(IdleMode bMode) {
        driveSparkMax.setIdleMode(bMode);
        turnSparkMax.setIdleMode(bMode);
    }

    // ----------------- Getter Methods ----------------- \\
    public double getMaxTurnSpeed() {
        return maxTurnSpeed;
    }

    public double getMaxDriveSpeed() {
        return maxDriveSpeed;
    }

    public double getAngle() {
        return turn_setpoint.getDouble(0.0);
    }

    public void getVelocity() {
        drive_setpoint.getDouble(0.0);
    }

    public double getCancoderAbsPosition() {
        return cANCoder.getAbsolutePosition();
    }

    double getTurnMotorValue() {
        return turnSparkMax.get();
    }

    double getDriveMotorValue() {
        return driveSparkMax.get();
    }

    public RelativeEncoder getEncoder() {
        return driveEncoder;
    }

}